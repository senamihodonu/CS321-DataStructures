import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Random;

/**
 * Hash table implementation driver class
 * 
 * @author Senami H
 *
 */
public class HashTableTest {
	private static int inputType = 0;
	private static double loadFactor = 0.0;
	private static int debug = 0;
	private static String dataSource;
	static DecimalFormat df = new DecimalFormat("#.##");
	static DecimalFormat df2 = new DecimalFormat("#.####");
	private final static int INITIAL_CAPACITY = 100; // starting capacity of debugArray
	private static Object[] debugArray = new Object[INITIAL_CAPACITY]; // array used in debug level 2
	private static int size = 0; // array size used in debug level 2
	private static LinearProbing<Object> linearP = new LinearProbing<Object>(loadFactor);
	private static DoubleHashing<Object> doubleH = new DoubleHashing<Object>(loadFactor);
	private static double[] alpha = {0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99};
	private static Object object;
	private static int linearIndex;
	private static int doubleIndex;

	public static void main(String[] args) {
		if (args.length < 2 || args.length > 3) {
			showUsage();
			throw new IllegalArgumentException();
		}

		// check loadFactor
		loadFactor = Double.parseDouble(args[1]);
		if (loadFactor < 0 || loadFactor > 1)
			throw new IllegalArgumentException("Illegal argument: loadFactor must >= 0 and <= 1.");

		// check debug level
		if (args.length == 3 && args[2].equals("0") || args.length == 2) {
			debug = 0;
      System.out.println("\n");
		} else if (args.length == 3 && args[2].equals("1")) {
			debug = 1;
      System.out.println("\n");
		} else if (args.length == 3 && args[2].equals("2")) {
			debug = 2;
			System.out.println("\nPrinting the elements...\n");
		} else {
			showUsage();
		}

		// data source used for experiment
		if (args[0].equals("1")) {
			dataSource = "java.util.Random";
			inputType = 1;
		} else if (args[0].equals("2")) {
			dataSource = "System.currentTimeMillis()";
			inputType = 2;
		} else if (args[0].equals("3")) {
			dataSource = "word-list";
			inputType = 3;
		} else {
			showUsage();
		}

		// check input type
		if (inputType == 1)
			InputTypeOne();
		else if (inputType == 2) {
			InputTypeTwo();
		} else if (inputType == 3) {
			InputTypeThree();
		} else {
			showUsage();
		}
	}

	/**
	 * Data Source 1: each HashObject contains an Integer object with a random int
	 * value generated by the method nextInt() in java.util.Random class. The key
	 * for each such HashObject is the Integer object inside.
	 */
	public static void InputTypeOne() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize());
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		while (doubleH.getLoadFactor() < loadFactor) {
			Random rand = new Random();
			int randInt = Math.abs(rand.nextInt(1000000));
			object = randInt;
			linearP.linearProbing(randInt);
			doubleH.doubleHashingInsert(randInt);
			ensureCapacity();
			debugArray[size] = randInt;
			size++;
			
		}
		debugLevel();
	}

	/**
	 * Data Source 2: each HashObject contains a Long object with a long value
	 * generated by the method System.currentTimeMillis(). The key for each such
	 * HashObject is the Long object inside.
	 */
	public static void InputTypeTwo() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize() + "\n");
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		while (linearP.getLoadFactor() < loadFactor) {
			long systemClock = System.currentTimeMillis();
			linearP.linearProbing(systemClock);
			doubleH.doubleHashingInsert(systemClock);
			ensureCapacity();
			debugArray[size] = systemClock;
			size++;
			
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

		debugLevel();
	}

	/**
	 * Data Source 3: each HashObject contains a word from the file word-list that
	 * provided with the starter files for this project. The key for each such
	 * HashObject is the word inside represented as a String type.
	 */
	public static void InputTypeThree() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize() + "\n");
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		try {
			BufferedReader br = new BufferedReader(new FileReader("word-list"));

			String word;

			while (((word = br.readLine()) != null) && doubleH.getLoadFactor() < loadFactor) {
				int linearIndex = linearP.linearProbing(word);
				int doubleIndex = doubleH.doubleHashingInsert(word);
				ensureCapacity();
				debugArray[size] = word;
				size++;

			}
			br.close();
		} catch (IOException e) {
			System.out.println("Could not open file!");
		}
		debugLevel();
	}

	/**
	 * Show usage for the program.
	 */
	public static void showUsage() {
		System.out.println("Usage: java HashtableTest <input type> <load factor> [<debug level>]\n"
				+ "\tinput type = 1 for random numbers, 2 for system time, 3 for word list\n"
				+ "\tdebug = 0 ==> print summary of experiment\n"
				+ "\tdebug = 1 ==> save the two hash tables to a file at the end\n"
				+ "\tdebug = 2 ==> print debugging output for each insert\n");

		System.exit(1);
	}

	/**
	 * Doubles the size of array used in debug level 2 when heap capacity reached.
	 */
	private static void ensureCapacity() {
		if (size == debugArray.length) {
			debugArray = Arrays.copyOf(debugArray, debugArray.length * 2);
		}
	}
	

	/**
	 * print summary of experiment on the console
	 */
	private static void statSummary(int getTotalElements, int getDuplicates, double loadFactor, double avgNumProbes) {
		System.out.println(
				"HashtableTest: Input " + getTotalElements + " elements, of which " + getDuplicates + " duplicates");
		System.out.println("HashtableTest: load factor = " + df.format(loadFactor) + ", Avg. no. of probes "
				+ df2.format(avgNumProbes) + "\n");
	}

	/**
	 * Debug levels for experiment
	 */
	private static void debugLevel() {
		if (debug == 0) {
			System.out.println("HashtableTest: Using Linear Hashing....");
			statSummary(linearP.getTotalElements(), linearP.getDuplicates(), linearP.getLoadFactor(),
					linearP.avgNumProbes());
			System.out.println("HashtableTest: Using Double Hashing....");
			statSummary(doubleH.getTotalElements(), doubleH.getDuplicates(), doubleH.getLoadFactor(),
					doubleH.avgNumProbes());

		}

		/*
		 * debug = 1: print summary of experiment on the console and also save the hash
		 * tables with number of duplicates and number of probes into two files
		 * linear-dump.txt and double-dump.txt.
		 */
		else if (debug == 1) {
			System.out.println("HashtableTest: Using Linear Hashing....");
			statSummary(linearP.getTotalElements(), linearP.getDuplicates(), linearP.getLoadFactor(),
					linearP.avgNumProbes());
			System.out.println("HashtableTest: Using Double Hashing....");
			statSummary(doubleH.getTotalElements(), doubleH.getDuplicates(), doubleH.getLoadFactor(),
					doubleH.avgNumProbes());

			// saving the hash tables with number of duplicates and number
			// of probes into two files linear-dump.txt and double-dump.txt.
			try {
				linearP.dump("linear-dump.txt");
				doubleH.dump("double-dump.txt");
				System.out.println("Dump complete...");
			} catch (FileNotFoundException e) {
				System.out.println("File name not found!");
			}

		}
		
		/*
		 * debug = 2: print element by element detailed output to help us debug and
		 * trace the behavior of the code.
		 */
		else if (debug == 2) {
			
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			for (int i = size; i >= 0; i--) {
				System.out.println("insert [" + i + "]: " + debugArray[i]);
			}
			
		}

	}
}
