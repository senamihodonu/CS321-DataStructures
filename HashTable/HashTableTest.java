import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Random;

/**
 * Hash table implementation driver class
 * 
 * @author Senami H
 *
 */
public class HashTableTest {
	private static int inputType = 0;
	private static double loadFactor = 0.0;
	private static int debug = 0;
	private static String dataSource;
	static DecimalFormat df = new DecimalFormat("#.##");
	static DecimalFormat df2 = new DecimalFormat("#.####");
	private static int size = 0; // array size used in debug level 2
	private static LinearProbing<Object> linearP = new LinearProbing<Object>(loadFactor);
	private static DoubleHashing<Object> doubleH = new DoubleHashing<Object>(loadFactor);
	private static Object object;
	private static int linearIndex;
	private static int doubleIndex;
	private static Object[] debugArray = new Object[linearP.getSize()]; // array used in debug level 2
	private static int seed = 1000000;

	/**
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		if (args.length < 2 || args.length > 3) {
			showUsage();
			throw new IllegalArgumentException();
		}

		// check loadFactor
		loadFactor = Double.parseDouble(args[1]);
		if (loadFactor < 0 || loadFactor > 1)
			throw new IllegalArgumentException("Illegal argument: loadFactor must >= 0 and <= 1.");

		// check debug level
		if (args.length == 3 && args[2].equals("0") || args.length == 2) {
			debug = 0;
		} else if (args.length == 3 && args[2].equals("1")) {
			debug = 1;
		} else if (args.length == 3 && args[2].equals("2")) {
			debug = 2;
			System.out.println("Printing the elements...\n");
		} else {
			showUsage();
		}

		// data source used for experiment
		if (args[0].equals("1")) {
			dataSource = "java.util.Random";
			inputType = 1;
		} else if (args[0].equals("2")) {
			dataSource = "System.currentTimeMillis()";
			inputType = 2;
		} else if (args[0].equals("3")) {
			dataSource = "word-list";
			inputType = 3;
		} else {
			showUsage();
		}

		// check input type
		if (inputType == 1)
			InputTypeOne();
		else if (inputType == 2) {
			InputTypeTwo();
		} else if (inputType == 3) {
			InputTypeThree();
		} else {
			showUsage();
		}
	}

	/**
	 * Data Source 1: each HashObject contains an Integer object with a random int
	 * value generated by the method nextInt() in java.util.Random class. The key
	 * for each such HashObject is the Integer object inside.
	 */
	public static void InputTypeOne() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize());
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		while (doubleH.getLoadFactor() < loadFactor) {
			Random rand = new Random();
			int randInt = Math.abs(rand.nextInt(seed));
			object = randInt;
			insertOperation();

		}
		debugLevel();
	}

	/**
	 * Data Source 2: each HashObject contains a Long object with a long value
	 * generated by the method System.currentTimeMillis(). The key for each such
	 * HashObject is the Long object inside.
	 */
	public static void InputTypeTwo() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize() + "\n");
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		while (linearP.getLoadFactor() <= loadFactor) {
			long systemClock = System.currentTimeMillis();
			object = systemClock;
			insertOperation();

			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

		debugLevel();
	}

	/**
	 * Data Source 3: each HashObject contains a word from the file word-list that
	 * provided with the starter files for this project. The key for each such
	 * HashObject is the word inside represented as a String type.
	 */
	public static void InputTypeThree() {
		System.out.println(
				"HashtableTest: Twin prime table size found in the range [95500..96000]: " + linearP.getSize() + "\n");
		System.out.println("HashtableTest: Data source type --> " + dataSource + "\n");

		try {
			BufferedReader br = new BufferedReader(new FileReader("word-list"));

			String word;

			while (((word = br.readLine()) != null) && doubleH.getLoadFactor() < loadFactor) {
				object = word;
				insertOperation();

			}
			br.close();
		} catch (IOException e) {
			System.out.println("Could not open file!");
		}
		debugLevel();
	}

	/**
	 * Show usage for the program.
	 */
	public static void showUsage() {
		System.out.println("Usage: java HashtableTest <input type> <load factor> [<debug level>]\n"
				+ "\tinput type = 1 for random numbers, 2 for system time, 3 for word list\n"
				+ "\tdebug = 0 ==> print summary of experiment\n"
				+ "\tdebug = 1 ==> save the two hash tables to a file at the end\n"
				+ "\tdebug = 2 ==> print debugging output for each insert\n");

		System.exit(1);
	}

	/**
	 * Doubles the size of array used in debug level 2 when heap capacity reached.
	 */
	private static void ensureCapacity() {
		if (size == debugArray.length) {
			debugArray = Arrays.copyOf(debugArray, debugArray.length * 2);
		}
	}

	/**
	 * Hash insert method calls
	 */
	private static void insertOperation() {
		linearIndex = linearP.linearProbing(object);
		doubleIndex = doubleH.doubleHashingInsert(object);
		ensureCapacity();
		debugArray[size] = object;
		size++;
	}

	/**
	 * print summary of experiment on the console
	 */
	private static void statSummary() {
		System.out.println("HashtableTest: Using Linear Hashing....");
		System.out.println("HashtableTest: Input " + linearP.getTotalElements() + " elements, of which "
				+ linearP.getDuplicates() + " duplicates");
		System.out.println("HashtableTest: load factor = " + df.format(linearP.getLoadFactor())
				+ ", Avg. no. of probes " + df2.format(linearP.avgNumProbes()) + "\n");

		System.out.println("HashtableTest: Using Double Hashing....");
		System.out.println("HashtableTest: Input " + doubleH.getTotalElements() + " elements, of which "
				+ doubleH.getDuplicates() + " duplicates");
		System.out.println("HashtableTest: load factor = " + df.format(doubleH.getLoadFactor())
				+ ", Avg. no. of probes " + df2.format(doubleH.avgNumProbes()) + "\n");
	}

	/**
	 * Debug levels for experiment
	 * 
	 * debug = 0: print summary of experiment on the console
	 * 
	 * debug = 1: print summary of experiment on the console and also save the hash
	 * tables with number of duplicates and number of probes into two files
	 * linear-dump.txt and double-dump.txt.
	 * 
	 * debug = 2: print element by element detailed output to help us debug and
	 * trace the behavior of the code.
	 * 
	 */
	private static void debugLevel() {
		if (debug == 0) {
			statSummary();
		}

		else if (debug == 1) {
			statSummary();
			// saving the hash tables with number of duplicates and number
			// of probes into two files linear-dump.txt and double-dump.txt.
			try {
				linearP.dump("linear-dump.txt");
				doubleH.dump("double-dump.txt");

			} catch (FileNotFoundException e) {
				System.out.println("File name not found!");
			}

		}

		else if (debug == 2) {

			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

			// print element by element
			for (int i = size; i >= 0; i--) {
				System.out.println("table[" + i + "]: " + debugArray[i]);

			}

		}

	}

	/**
	 * @return the linearIndex
	 */
	public static int getLinearIndex() {
		return linearIndex;
	}

	/**
	 * @return the doubleIndex
	 */
	public static int getDoubleIndex() {
		return doubleIndex;
	}
}
//https://www.programiz.com/java-programming/examples/round-number-decimal